#ifndef KOCSYMM_HPP
# define KOCSYMM_HPP
# include "../cubepos/cubepos.hpp"
# include <iostream>

// the two-phase algjorythm is based on the subgroup generated by {U, F2, R2, D, B2, L2} = H.
// we have to find an arbitrary cube position and find a subsequence to bring it in the subgroup
// then solve it within the subgroup.
// the first part is finding a path within the Schreier coset graph of H to the trivial coset
// the second part is solving within the coset.

// *** lesson 2

const int CORNERSYMM = 2187;
const int EDGEOSYMM = 2048;
const int EDGEPERM = 495;

// constant for cocsymm and permcube *** lesson 18

const int KOCSYMM = 16;
const int CORNERRSYMM = 168;

// *** lesson 19

struct corner_mapinfo 
{
	unsigned short minbits;
	unsigned char csymm, minmap;
};

typedef unsigned short lookup_type;

class kocsymm 
{
	public:
	kocsymm() : csymm(0), eosymm(0), epsymm(0) {}
	kocsymm(int c, int eo, int ep) : csymm(c), eosymm(eo), epsymm(ep) {}

	// METHOD FOR KOCSYMM *** lesson 3

	kocsymm(int) : csymm(0), eosymm(0), epsymm(0) 
	{
		init();
	}

	static void init();
	// *** lesson 5

	inline bool operator < (const kocsymm &kc) const
	{
		if (csymm != kc.csymm)
			return (csymm < kc.csymm);
		if (eosymm != kc.eosymm)
			return (eosymm < kc.eosymm);
		return (epsymm < kc.epsymm);
	}

	inline bool operator== (const kocsymm &kc) const
	{
		return (kc.csymm == csymm && kc.eosymm == eosymm && kc.epsymm == epsymm);
	}

	inline bool operator!=(const kocsymm &kc) const
	{
		return (kc.csymm != csymm || kc.eosymm != eosymm || kc.epsymm != epsymm);
	}

	// *** lesson 9

	void move (int mv)
	{
		csymm = cornermove[csymm][mv];
		eosymm = edgeomove[eosymm][mv];
		epsymm = edgepmove[epsymm][mv];
	}

	// *** lesson 10

	kocsymm(const cubepos &cp);
	void set_coset(cubepos &cp);

	// *** lesson 24

	void canon_into(kocsymm &kc) const;

	// *** lesson 26

	int calc_symm() const;

	// *** lesson 28

	static inline int in_Kocieba_group(int mv)
	{
		return (edgepmove[0][mv] == 0);
	}

	// STATIC DATA DECLARATION FOR KOCSYMM *** lesson 6

	static lookup_type cornermove[CORNERSYMM][NMOVES];
	static lookup_type edgeomove[EDGEOSYMM][NMOVES];
	static lookup_type edgepmove[EDGEPERM][NMOVES];

	// *** lesson 11
	static lookup_type epsymm_compress[1 << 12];
	static lookup_type epsymm_expand[EDGEOSYMM];

	// *** lesson 20

	static lookup_type cornesymm_expand[CORNERRSYMM];
	static corner_mapinfo cornersymm[CORNERSYMM];
	static lookup_type edgeomap[EDGEOSYMM][KOCSYMM];
	static lookup_type edgepmap[EDGEPERM][KOCSYMM];
	static lookup_type edgepxor[EDGEPERM][2];

	lookup_type csymm, eosymm, epsymm; 
};

// *** lesson 4

static kocsymm identity_kc(1);

// *** lesson 29

const int FACT4 = 24;
const int C8_4 = 70;

class permcube 
{
	public:

	permcube();

	// METHODS FOR PERMCUBE *** lesson 42
	inline bool operator < (const permcube &pc) const
	{
		if (et != pc.et)
			return (et < pc.et);
		if (em != pc.em)
			return (em < pc.em);
		if (eb != pc.eb)
			return (eb < pc.eb);
		if (etp != pc.etp)
			return (etp < pc.etp);
		if (emp != pc.emp)
			return (emp < pc.emp);
		if (ebp != pc.ebp)
			return (ebp < pc.ebp);
		if (c8_4 != pc.c8_4)
			return (c8_4 < pc.c8_4);
		if (ctp != pc.ctp)
			return (ctp < pc.ctp);
		return (cbp < pc.cbp);
	}
	
	inline bool operator==(const permcube &pc) const
	{
		return (et == pc.et && em == pc.em && eb == pc.eb && etp == pc.etp && emp == pc.emp && ebp == pc.ebp && c8_4 == pc.c8_4 && ctp == pc.ctp && cbp == pc.cbp);
	}

	inline bool operator!=(const permcube &pc) const
	{
		std::cout << et << " " << pc.et << std::endl;
		std::cout << (et != pc.et) << std::endl;
		std::cout << em << " " << pc.em << std::endl;
		std::cout << (em != pc.em) << std::endl;
		std::cout << eb << " " << pc.eb << std::endl;
		std::cout << (eb != pc.eb) << std::endl;
		std::cout << (int)etp << " " << (int)pc.etp << std::endl;
		std::cout << (etp != pc.etp) << std::endl;
		std::cout << (int)emp << " " << (int)pc.emp << std::endl;
		std::cout << (emp != pc.emp) << std::endl;
		std::cout << (int)ebp << " " << (int)pc.ebp << std::endl;
		std::cout << (ebp != pc.ebp) << std::endl;
		std::cout << (int)c8_4 << " " << (int)pc.c8_4 << std::endl;
		std::cout << (c8_4 != pc.c8_4) << std::endl;
		std::cout << (int)ctp << " " << (int)pc.ctp << std::endl;
		std::cout << (ctp != pc.ctp) << std::endl;
		std::cout << (int)cbp << " " << (int)pc.cbp << std::endl;
		std::cout << (cbp != pc.cbp) << std::endl;
		return (et != pc.et || em != pc.em || eb != pc.eb || etp != pc.etp || emp != pc.emp || ebp != pc.ebp || c8_4 != pc.c8_4 || ctp != pc.ctp || cbp != pc.cbp);
	}

	// *** lesson 45
	void move(int mv);

	// *** lesson 47
	void init_edge_from_cp(const cubepos &cp);
	void init_corner_from_cp(const cubepos &cp);
	permcube(const cubepos &cp);
	void set_edge_perm(cubepos &cp) const;
	void set_corner_perm(cubepos &cp) const;
	void set_perm(cubepos &cp) const;

	static void init();

	// STATIC DATA DECLARATION FOR PERMCUBE *** lesson 31

	static unsigned char s4inv[FACT4];
	static unsigned char s4mul[FACT4][FACT4];
	static unsigned char s4compress[256];
	static unsigned char s4expand[FACT4];

	// *** lesson 36
	static unsigned char c8_4_compact[256];
	static unsigned char c8_4_expand[C8_4];
	static unsigned char c8_4_parity[C8_4];
	
	// *** lesson 39
	static unsigned char c12_8[EDGEPERM];
	static lookup_type c8_12[C8_4];

	// *** lesson 43
	static unsigned short eperm_move[EDGEPERM][NMOVES];
	static int cperm_move[C8_4][NMOVES];

	unsigned short et, em, eb;
	unsigned char etp, emp, ebp;
	unsigned char c8_4, ctp, cbp;
};

// *** lesson 30

static permcube identity_pc;

// lesson 55
#endif