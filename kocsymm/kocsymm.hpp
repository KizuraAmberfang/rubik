#ifndef KOCSYMM_HPP
# define KOCSYMM_HPP
# include "../cubepos/cubepos.hpp"

// the two-phase algjorythm is based on the subgroup generated by {U, F2, R2, D, B2, L2} = H.
// we have to find an arbitrary cube position and find a subsequence to bring it in the subgroup
// then solve it within the subgroup.
// the first part is finding a path within the Schreier coset graph of H to the trivial coset
// the second part is solving within the coset.

// *** lesson 2

const int CORNERSYMM = 2187;
const int EDGEOSYMM = 2048;
const int EDGEPERM = 495;

// constant for cocsymm and permcube *** lesson 18

const int KOCSYMM = 16;
const int CORNERRSYMM = 168;

// *** lesson 19

struct corner_mapinfo 
{
	unsigned short minbits;
	unsigned char csymm, minmap;
};

typedef unsigned short lookup_type;

class kocsymm 
{
	public:
	kocsymm() : csymm(0), eosymm(0), epsymm(0) {}
	kocsymm(int c, int eo, int ep) : csymm(c), eosymm(eo), epsymm(ep) {}

	// METHOD FOR KOCSYMM *** lesson 3

	kocsymm(int) : csymm(0), eosymm(0), epsymm(0) 
	{
		init();
	}

	static void init();
	// *** lesson 5

	inline bool operator < (const kocsymm &kc) const
	{
		if (csymm != kc.csymm)
			return (csymm < kc.csymm);
		if (eosymm != kc.eosymm)
			return (eosymm < kc.eosymm);
		return (epsymm < kc.epsymm);
	}

	inline bool operator== (const kocsymm &kc) const
	{
		return (kc.csymm == csymm && kc.eosymm == eosymm && kc.epsymm == epsymm);
	}

	inline bool operator!=(const kocsymm &kc) const
	{
		return (kc.csymm != csymm || kc.eosymm != eosymm || kc.epsymm != epsymm);
	}

	// *** lesson 9

	void move (int mv)
	{
		csymm = cornermove[csymm][mv];
		eosymm = edgeomove[eosymm][mv];
		epsymm = edgepmove[epsymm][mv];
	}

	// *** lesson 10

	kocsymm(const cubepos &cp);
	void set_coset(cubepos &cp);

	// *** lesson 24

	void canon_into(kocsymm &kc) const;

	// *** lesson 26

	int calc_symm() const;

	// *** lesson 28

	static inline int in_Kocieba_group(int mv)
	{
		return (edgepmove[0][mv] == 0);
	}

	// STATIC DATA DECLARATION FOR KOCSYMM *** lesson 6

	static lookup_type cornermove[CORNERSYMM][NMOVES];
	static lookup_type edgeomove[EDGEOSYMM][NMOVES];
	static lookup_type edgepmove[EDGEPERM][NMOVES];

	// *** lesson 11
	static lookup_type epsymm_compress[1 << 12];
	static lookup_type epsymm_expand[EDGEOSYMM];

	// *** lesson 20

	static lookup_type cornesymm_expand[CORNERRSYMM];
	static corner_mapinfo cornersymm[CORNERSYMM];
	static lookup_type edgeomap[EDGEOSYMM][KOCSYMM];
	static lookup_type edgepmap[EDGEPERM][KOCSYMM];
	static lookup_type edgepxor[EDGEPERM][2];

	lookup_type csymm, eosymm, epsymm; 
};

// *** lesson 4

static kocsymm identity_kc(1);

// lesson 29
// lesson 30
// lesson 55
#endif